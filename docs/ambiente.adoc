= Ambiente de Desenvolvimento

== Plataforma

Muito dificilmente hoje um programador inicia um projeto apenas com um editor de texto e um compilador. 
Normalmente se utiliza muita coisa de suporte que aumentam a produtividade a médio prazo mas são muitas vezes mais 
difíceis de se dominar do que uma linguagem de programação em si. 
	
Quando falamos em desenvolvimento de software que tem por objetivo ser utilizado por uma grande massa de usuários, 
em meio governamental, privado e/ou livre, normalmetne pensamos em que "plataforma" seria melhor desenvolver este projeto. 
Plataforma nesse caso se refere ao conjunto de tecnologias utilizadas para desenvolver, testar e distibuir a aplicação e que 
dão suporte a estas. A linguagem de programação utilizada é um componente importante e normalmente é o "carro chefe" da plataforma,
 mas não é o único componente. Por exemplo: quando alguém diz que irá desenvolver um sistema web, digamos,  de matrícula de uma 
 universidade, "em Java" normalmente esta pessoa se refere a plataforma Java ao invés de apenas a línguagem Java. 
 Isto porque além de escrever código fonte em Java ele irá escrever inúmeros arquivos em xml e outras linguagens e utilizar uma 
 determinado conjunto de ferramentas do "mundo Java". Se por outro lado ele decidisse utilizar a plataforma .net ele não seria apenas 
 a línguagem de programação que iria variar mas também componentes reutilizaveis, servidor de aplicação, etc. 
 Se por outro lado resolvesse desenvolver a mesma aplicação, mas para "plataforma Android" a línguagem de programação utilizada 
 poderia ser a mesma, Java, mas se utilizaria outras ferramentas de suporte.

== Compilador / Interpretador / JIT

Até as primeira metade dos anos 2000 se falava muito em linguagens interprestada e linguagens compiladas. 
E que linguagens interprestada eram executadas em um interpretador equanto as compiladas eram processadas 
pelo compilador que gerava código nativo que era diretamente executado na máquina. Nos últimos anos esta 
visão ficou mais complicada:
.Muitas linguagens possuem compiladores e interprestadores para elas e podem ser interpretadas ou compiladas.
.Existem máquinas virtuais que executam código compilado para máquinas abstratas (bytecodes) (JVM, .Net, Flashplayer)
.Existem compiladores JIT (Just in time) que compilam código ou bytecodes em tempo de execução do programa para otimizar 
sua execução. Ex: JVM (bytecodes Java), Chrome V8 (Javascript)



== IDE
IDE ( Integrated Development Environment) é um ambiente de desenvolvimento integrado utilzado por equipes de desenvolvimento 
para desenvolver um determinado projeto de sofware. Esses ambientes oferecem normalmente Editor de Texto com funcionalidades 
úteis para digitar código fonte, como Highlight, autocompletar sensível ao contexto, integração com compiladores, debuggers, 
configurações de projetos e etc.

IDEs muito utilizadas para desenvolvimento Java são: Eclipse, Netbens, IntelliJ IDEA.

=== Eclipse

É uma IDE opensource, uma das mais avançadas e populares do mundo, que se popularizou no ambiente de desenvolvimento Java 
mas que hoje conta com versões para diversas 0linguanges/plataformas. O Eclipse facilitar a atividade de codificação - 
oferecendo funcionalidade de auto-complete, busca de referências à métodos, classes e variáveis, auxílio para renomear classes e métodos.

É uma ferramenta muito extensível, possuindo integrado um ambiente de download de plugins que podem extender suas funcionalidades. 
Algumas empresas oferecem IDEs baseadas no Eclipse para desenvolvimento em plataformas proprietárias ou patrocinadas. 
O Google, por exemplo, disponibiliza um pacote com Eclipse para desenvolvimento para Apps Android. 

== Gerencia de Dependências em Java

Uma das grandes vantagens atuais da plataforma Java nos dias de hoje é a disponibilidade de uma extensa quantidade de bibliotecas 
de software disponíveis gratuitamente, em projetos open source ou por forcededores que licenciam bibliotecas. 
A utilização de tais bibliotecas podem diminuir o tempo e baratear em muito o desenvolvimento de novos projetos. 
Algumas bibliotecas são distribuidas junto com o JRE (Java Runtime Edition) e estão disponíveis para qualquer pessoa que possua Java 
instalado em seu dispositivo. Algumas outras bibliotecas caso utilizadas precisam ser distribuidas junto com a aplicação (tipo runtime). 
Algumas são necessárias em tempo de compilação (considera-se que o usuário terá as dependências em sua plataforma no momento da execução. 
Ex: dependências nativas Android). Algumas outras serão necessárias apenas quando se executar os testes da aplicação (tipo test).
As bibliotecas Java normalmente são distribuidas em arquivos compactados com a extensão ".jar".


=== Gradle / Repo Maven

Para projetos complexos em Java, normalmente se utilzia dezenas de bibliotecas forncedidas por terceiros. 
Cada biblioteca por sua vez costuma depender de outras bibliotecas. Nesse cenário é fácil chegar a uma situação em que é 
muito complexo gerenciar todas as dependências de um programa. Por isso é muito comum utilizar sistemas 
gerenciadores de build e dependências. Esses sistemas são capazes de baixar as bibliotecas das quais um sistema depende 
antes de compilar e empacotar uma aplicação. Isso facilita em muito o processo de build de um sistema.

Uma outras grande vantagem de tais sistema é que normalmente utilizam arquivos texto de configurações que especificam 
as dependências de tais sistemas. Estes arquivos são versionados juntamente com o restante do código da aplicação 
permitindo controle e rastreabilidade. 


=== Gradle: Plugin Java

Gradle expects to find your production source code under src/main/java and your test source code under src/test/java. 
In addition, any files under src/main/resources will be included in the JAR file as resources, and any files under 
src/test/resources will be included in the classpath used to run the tests. All output files are created under the 
build directory, with the JAR file ending up in the build/libs directory.
 	
 The Java plugin adds quite a few tasks to your project. The most commonly used task is the build task, which does a 
 full build of the project. When you run gradle build, Gradle will compile and test your code, and create a JAR file 
 containing your main classes and resources:


clean:: 
Deletes the build directory, removing all built files.

assemble::
Compiles and jars your code, but does not run the unit tests. Other plugins add more artifacts to this task. For example, if you use the War plugin, this task will also build the WAR file for your project. 

check::
Compiles and tests your code. Other plugins add more checks to this task. For example, if you use the checkstyle plugin, this task will also run Checkstyle against your source code. 


=== External dependencies

Usually, a Java project will have some dependencies on external JAR files. 
To reference these JAR files in the project, you need to tell Gradle where to find them. 
In Gradle, artifacts such as JAR files, are located in a repository. A repository can be used for 
fetching the dependencies of a project, or for publishing the artifacts of a project, or both. For this example, 
we will use the public Maven repository:

Example 7.3. Adding Maven repository

build.gradle

repositories {
    mavenCentral()
}



Get's add some dependencies. Here, we will declare that our production classes have a compile-time dependency on commons 
collections, and that our test classes have a compile-time dependency on junit:

Example 7.4. Adding dependencies

build.gradle

dependencies {
    compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
    testCompile group: 'junit', name: 'junit', version: '4.+'
}


== Publishing the JAR file

Usually the JAR file needs to be published somewhere. To do this, you need to tell Gradle where to publish the JAR file. 
In Gradle, artifacts such as JAR files are published to repositories. In our sample, we will publish to a local directory. 
You can also publish to a remote location, or multiple locations.

Example 7.7. Publishing the JAR file

build.gradle

uploadArchives {
    repositories {
       flatDir {
           dirs 'repos'
       }
    }
}

To publish the JAR file, run gradle uploadArchives.

// TODO  repo jars do projeto


== Multi-project Java build

Now let's look at a typical multi-project build. Below is the layout for the project:

Example 7.10. Multi-project build - hierarchical layout

Build layout

multiproject/
  api/
  services/webservice/
  shared/


= Controle de Versões

== SCM 
	SCM (Sistema de Controle de Versão) ou (VCS) Version control systems são ferramentas utilizadas para compartilhamento e versionamento de artefatos entre equipes. Estes artefatos são código fonte, documentação, diagramas UML, scripts de banco de dados, etc.

	A utilização de tais ferramentas é  uma prática muito comum nos ambiente de desenvolvimento coorporativo e opensource. Está é muito possivelmente depois de compiladores e editores de texto a ferramenta mais utilizada por programadores. 

	O SCM registra as mudanças realizadas em um conjunto de arquivo e permite recuperar versões anteriores do arquivo e acompanhar as modificações em cada um dos arquivos.

=== GIT

git init::
Inicia um novo repositorio

git clone::
Clona um repositório existente


git commit::
cada commit representa um estado do projeto. Como salvar uma fase em um jogo.

git add::
Marca os arquivos para serem adicionados no próximo commit

git log::
Visualiza os commits mais recentes

git pull::
Atualiza o repositório local

git push::
Atualiza o repositório remoto

git remote add origin <repositorio>::
Adiciona um repositorio remoto

== Workflow no nosso projeto:

Crie uma pasta para conter seus repositórios git
c:\dev\git

Clonando o repositório para a sua máquina
$cd c:\dev\git
$git clone http

Agora você pode importar no eclipse.


Crie uma branch para você trabalhar.
$git branch


Comite uma pequena modificação, por exemplo, um teste que você implementou e passou.

Primeiro vemos o que foi modificado
$git status


Selecionar arquivos (adicionando snapshots deles na sua área de seleção.)
$git add <arquivo>
ou 
$git add .

Vamos commitar o que é relevante

$git commit -m "Implementando Teste X"


Obtenha do servidor as mudanças mais recentes.
$git pull


Você terminou de implementar uma funcionalidade
$git checkout <branch principal>
$git merge
$git commit
$git push

Sua feature passará pelo processo de aprovação e hopefully está presente no master e será publicada no próximo nighty


Os três estados

.Modificado (modified)
.Preparado (staged)
.Consolidado (commited)

=== Github


== Bug Tacker

=== JIRA

== Base de Conhecimento

=== WIKI


== Integração Contínua
= Jenkins

== Análise Estática de Código

= Sonar


== Processos

= Deploy 

== Deploy Automatizado


= Suporte ao Usuário / Rastreamento de Bugs
